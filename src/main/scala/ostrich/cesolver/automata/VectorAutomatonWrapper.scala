package ostrich.cesolver.automata

import ostrich.cesolver.util.ParikhUtil
import scala.collection.mutable.{HashSet => MHashSet, HashMap => MHashMap, ArrayStack => MStack, ArrayBuffer}


object VectorAutomatonWrapper {
  def apply (underlying: CostEnrichedAutomatonBase): VectorAutomatonWrapper = new VectorAutomatonWrapper(underlying)
}

// The vector automaton is obtained by ignoring the alphabets of underlying automaton and only considering the vectors of the transitions.
// The emptiness check of vector automaton is less expensive but same precision as the underlying automaton.
class VectorAutomatonWrapper(underlying: CostEnrichedAutomatonBase)
    extends CostEnrichedAutomaton {

  private val old2new = underlying.states.map(s => (s, newState())).toMap
  private val labelPlaceholder = ('a', 'a')

  // initialize
  initialState = old2new(underlying.initialState)
  for (s <- underlying.states) {
    for ((t, v) <- underlying.outgoingTransitionsWithoutLabel(s)) addTransition(old2new(s), labelPlaceholder, old2new(t), v)
  }
  for (s <- underlying.acceptingStates) setAccept(old2new(s), true)
  registers = underlying.registers
  regsRelation = underlying.regsRelation

  // NOTE: Following functions are only complete for emptiness check. These funcitons do not reserve the semantic of the automaton.
  // For example, the automaton generated by epsilonClosureByVec may reject some strings that are not rejected by the original automaton.
  // ---------------------------------------------------------------------------------------------------------------------
  private def epsilonClosureByVec(aut: CostEnrichedAutomatonBase): CostEnrichedAutomatonBase = {
    if (aut.registers.isEmpty) return aut
    ParikhUtil.log(
      "CEBasicOperations.epsilonClosureByVec: compute epsilon closure of automata by considering registers update (0,...,0) as epsilon"
    )
    val ceAut = new CostEnrichedAutomaton
    val old2new = aut.states.map(s => (s, ceAut.newState())).toMap
    for (s <- aut.states) {
      if (aut.isAccept(s)) ceAut.setAccept(old2new(s), true)
      // get the epsilon closure
      val epsClosureSet = MHashSet[State](s)
      val workstack = MStack[State](s)
      val seen = MHashSet[State](s)
      while (workstack.nonEmpty) {
        ap.util.Timeout.check
        val cur = workstack.pop()
        for ((t, _, v) <- aut.outgoingTransitions(cur)) {
          if (v.forall(_ == 0) && !seen(t)) {
            workstack.push(t)
            epsClosureSet.add(t)
            if (aut.isAccept(t)) ceAut.setAccept(old2new(s), true)
            seen.add(t)
          }
        }
      }
      // generate new transitions
      for (
        se <- epsClosureSet; (t, l, v) <- aut.outgoingTransitions(se); if v.exists(_ != 0)
      ) ceAut.addTransition(old2new(s), l, old2new(t), v)
    }
    ceAut.initialState = old2new(aut.initialState)

    ceAut.registers = aut.registers
    ceAut.regsRelation = aut.regsRelation
    ceAut
  }

  private def determinateByVec(aut: CostEnrichedAutomatonBase): CostEnrichedAutomatonBase = {
    if (aut.registers.isEmpty) return aut
    val ceAut = new CostEnrichedAutomaton
    val seq2new = new MHashMap[Set[State], State]
    val workstack = new MStack[Set[State]]

    val initialState = ceAut.initialState
    seq2new += (Set(aut.initialState) -> initialState)
    workstack.push(Set(aut.initialState))

    while (workstack.nonEmpty) {
      ap.util.Timeout.check

      val curSeq = workstack.pop()
      val curState = seq2new(curSeq)
      val curTrans = new MHashMap[Seq[Int], Set[State]]
      for (s <- curSeq) {
        for ((t, l, v) <- aut.outgoingTransitions(s)) {
          if (curTrans.contains(v)) curTrans(v) = curTrans(v) ++ Set(t)
          else curTrans += (v -> Set(t))
        }
      }
      for ((v, seq) <- curTrans) {
        if (!seq2new.contains(seq)) {
          seq2new += (seq -> ceAut.newState())
          workstack.push(seq)
        }
        ceAut.addTransition(curState, labelPlaceholder, seq2new(seq), v)
      }
    }

    for ((seq, s) <- seq2new) { if (seq.exists(aut.isAccept)) ceAut.setAccept(s, true) }

    ceAut.registers = aut.registers
    ceAut.regsRelation = aut.regsRelation
    ceAut
  }

  private def partitionStatesByVec(aut: CostEnrichedAutomatonBase) = {
    if (aut.registers.isEmpty) aut
    val pairs = new MHashSet[Set[State]]()
    for (s <- aut.states; t <- aut.states; if s != t) pairs.add(Set(s, t))
    val pair2dependingList = new MHashMap[Set[State], ArrayBuffer[Set[State]]]()
    for (pair <- pairs) {
      val state1 = pair.head
      val state2 = pair.last
      for ((source1, l1, v1) <- aut.incomingTransitions(state1)) {
        for ((source2, l2, v2) <- aut.incomingTransitions(state2); if v1 == v2) {
          ap.util.Timeout.check
          if (source1 != source2) {
            pair2dependingList.getOrElseUpdate(pair, ArrayBuffer()) += Set(source1, source2)
          }
        }
      }
    }
    val distinguishedPairs = new MHashSet[Set[State]]()
    val baseDistinguishedPairs = new MHashSet[Set[State]]()
    for (pair <- pairs) {
      if (aut.isAccept(pair.head) != aut.isAccept(pair.last)) { baseDistinguishedPairs.add(pair) }
      else {
        val outVecs1 = aut.outgoingTransitions(pair.head).map { case (_, _, v) => v }.toSet
        val outVecs2 = aut.outgoingTransitions(pair.last).map { case (_, _, v) => v }.toSet
        if (outVecs1 != outVecs2) { baseDistinguishedPairs.add(pair) }
      }
    }
    var lastDistinguishedPairs = baseDistinguishedPairs
    while (lastDistinguishedPairs.nonEmpty) {
      distinguishedPairs ++= lastDistinguishedPairs
      val newDistinguishedPairs = new MHashSet[Set[State]]()
      for (pair <- lastDistinguishedPairs; if pair2dependingList.contains(pair)) {
        for (dependingPair <- pair2dependingList(pair)) {
          if (!distinguishedPairs.contains(dependingPair)) {
            newDistinguishedPairs.add(dependingPair)
          }
        }
      }
      lastDistinguishedPairs = newDistinguishedPairs
    }
    val s2equivalentClass = new MHashMap[State, MHashSet[State]]
    for (s <- aut.states) s2equivalentClass += (s -> MHashSet(s))
    for (pair <- pairs) {
      if (!distinguishedPairs.contains(pair)) {
        val s1 = pair.head
        val s2 = pair.last
        s2equivalentClass(s1) ++= s2equivalentClass(s2)
        s2equivalentClass(s2) = s2equivalentClass(s1)
      }
    }
    val equalClass2rep = new MHashMap[Set[State], State]
    val s2reprensentive = new MHashMap[State, State]
    for (equalClass <- s2equivalentClass.values) {
      equalClass2rep.getOrElseUpdate(equalClass.toSet, aut.newState())
    }
    for ((s, set) <- s2equivalentClass) { s2reprensentive(s) = equalClass2rep(set.toSet) }
    s2reprensentive
  }

  private def minimizeHopcroftByVec(aut: CostEnrichedAutomatonBase): CostEnrichedAutomatonBase = {
    if (aut.registers.isEmpty) return aut
    ParikhUtil.log(
      "CEBasicOperations.minimizeHopcroftByVec: minimize automata according to registers updates (do not minimize if the automata is much larger after determinization)"
    )
    val afterEpsilonClosure = epsilonClosureByVec(aut)
    val afterDetermine = determinateByVec(afterEpsilonClosure)
    ParikhUtil
      .log("aut size is " + aut.size() + ", afterDetermineByVec size is " + afterDetermine.size())
    if (
      afterDetermine.size() > ParikhUtil.MAX_MINIMIZE_SIZE
    ) // the overhead of minimization is too large (heuristic)
      return if (aut.size() < afterDetermine.size()) aut else afterDetermine
    if (
      afterDetermine.size() / ParikhUtil.MAX_DETERMIN_EXPAND > aut.size()
    ) // the minimization is not effective (heuristic)
      return aut
    val s2representive = partitionStatesByVec(afterDetermine)
    val ceAut = new CostEnrichedAutomaton
    ceAut.initialState = s2representive(afterDetermine.initialState)
    for ((s, l, t, v) <- afterDetermine.transitions) ceAut
      .addTransition(s2representive(s), l, s2representive(t), v)
    for (s <- afterDetermine.acceptingStates) ceAut.setAccept(s2representive(s), true)
    ceAut.regsRelation = afterDetermine.regsRelation
    ceAut.registers = afterDetermine.registers
    ParikhUtil.log("After minimizeHopcroftByVec, size is " + ceAut.size())
    CEBasicOperations.removeDuplicatedReg(ceAut)
  }
  // ---------------------------------------------------------------------------------------------------------------------

}
